package robogp.matchmanager;

import Match.Card;
import java.awt.CardLayout;
import java.io.File;
import java.util.ArrayList;
import javax.swing.DefaultComboBoxModel;
import javax.swing.DefaultListModel;
import javax.swing.JOptionPane;
import robogp.robodrome.BeltCell;
import robogp.robodrome.BoardCell;
import robogp.robodrome.Direction;
import robogp.robodrome.FloorCell;
import robogp.robodrome.PitCell;
import robogp.robodrome.Robodrome;
import robogp.robodrome.Rotation;
import robogp.robodrome.view.RobodromeView;

/**
 *
 * @author claudia
 */
public class MatchManagerApp extends javax.swing.JFrame {
    
    private static MatchManagerApp singleInstance;
    private RobotStatePanel[] robotPanel;
    public static RobodromeView rdView;
    private int TOTALROBOTS;
    
    private MatchManagerApp() {
        initComponents();
        this.inizPartCtrl = IniziarePartitaController.getInstance();
        this.robotChooser = new RobotChooser(this, true);
    }
    
    public static MatchManagerApp getAppInstance() {
        return MatchManagerApp.singleInstance;
    }
    
    private final IniziarePartitaController inizPartCtrl;
    
    private final RobotChooser robotChooser;
    
    public IniziarePartitaController getIniziarePartitaController() {
        return this.inizPartCtrl;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        initPanel = new javax.swing.JPanel();
        javax.swing.JPanel jPanel4 = new javax.swing.JPanel();
        javax.swing.JPanel jPanel1 = new javax.swing.JPanel();
        javax.swing.JPanel jPanel2 = new javax.swing.JPanel();
        javax.swing.JLabel jLabel1 = new javax.swing.JLabel();
        portField = new javax.swing.JTextField();
        javax.swing.JPanel jPanel3 = new javax.swing.JPanel();
        javax.swing.JLabel jLabel2 = new javax.swing.JLabel();
        keyField = new javax.swing.JTextField();
        javax.swing.JPanel jPanel5 = new javax.swing.JPanel();
        initButton = new javax.swing.JButton();
        matchPanel = new javax.swing.JPanel();
        javax.swing.JPanel jPanel6 = new javax.swing.JPanel();
        createButton = new javax.swing.JButton();
        javax.swing.JPanel jPanel7 = new javax.swing.JPanel();
        javax.swing.JPanel jPanel10 = new javax.swing.JPanel();
        javax.swing.JPanel jPanel11 = new javax.swing.JPanel();
        javax.swing.JLabel jLabel3 = new javax.swing.JLabel();
        robodromeCombo = new javax.swing.JComboBox<>();
        javax.swing.JPanel jPanel12 = new javax.swing.JPanel();
        javax.swing.JLabel jLabel4 = new javax.swing.JLabel();
        endGameCombo = new javax.swing.JComboBox<>();
        javax.swing.JPanel jPanel13 = new javax.swing.JPanel();
        javax.swing.JLabel jLabel5 = new javax.swing.JLabel();
        maxPlayersCombo = new javax.swing.JComboBox<>();
        javax.swing.JPanel jPanel14 = new javax.swing.JPanel();
        javax.swing.JLabel jLabel6 = new javax.swing.JLabel();
        nRobotsCombo = new javax.swing.JComboBox<>();
        upgradeCheck = new javax.swing.JCheckBox();
        playersPanel = new javax.swing.JPanel();
        javax.swing.JPanel jPanel8 = new javax.swing.JPanel();
        javax.swing.JScrollPane jScrollPane1 = new javax.swing.JScrollPane();
        requestList = new javax.swing.JList<>();
        javax.swing.JPanel jPanel15 = new javax.swing.JPanel();
        acceptRequestButton = new javax.swing.JButton();
        rejectRequestButton = new javax.swing.JButton();
        robotRecapPanel = new javax.swing.JPanel();
        javax.swing.JPanel jPanel16 = new javax.swing.JPanel();
        startMatchButton = new javax.swing.JButton();
        cancelMatchButton = new javax.swing.JButton();
        ongoingMatchPanel = new javax.swing.JPanel();
        titolo = new javax.swing.JLabel();
        tabellone = new javax.swing.JSplitPane();
        controlActionPanel = new javax.swing.JPanel();
        jSplitPane1 = new javax.swing.JSplitPane();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("RoboGP Match Manager");
        setName("main frame"); // NOI18N
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });
        getContentPane().setLayout(new java.awt.CardLayout());

        initPanel.setBorder(javax.swing.BorderFactory.createEmptyBorder(20, 5, 5, 5));
        initPanel.setLayout(new java.awt.BorderLayout());

        jPanel4.setBorder(javax.swing.BorderFactory.createEmptyBorder(5, 5, 5, 5));

        jPanel1.setLayout(new javax.swing.BoxLayout(jPanel1, javax.swing.BoxLayout.Y_AXIS));

        jPanel2.setLayout(new java.awt.BorderLayout());

        jLabel1.setFont(new java.awt.Font("Lucida Grande", 0, 14)); // NOI18N
        jLabel1.setText("Porta su cui girerà il server di gioco:");
        jPanel2.add(jLabel1, java.awt.BorderLayout.WEST);

        portField.setColumns(6);
        portField.setText("2222");
        jPanel2.add(portField, java.awt.BorderLayout.CENTER);

        jPanel1.add(jPanel2);

        jPanel3.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 30, 0));
        jPanel3.setLayout(new java.awt.BorderLayout());

        jLabel2.setFont(new java.awt.Font("Lucida Grande", 0, 14)); // NOI18N
        jLabel2.setText("Parola chiave per l'accesso al server:");
        jPanel3.add(jLabel2, java.awt.BorderLayout.WEST);

        keyField.setColumns(10);
        jPanel3.add(keyField, java.awt.BorderLayout.CENTER);

        jPanel1.add(jPanel3);

        jPanel4.add(jPanel1);

        initPanel.add(jPanel4, java.awt.BorderLayout.CENTER);

        jPanel5.setBorder(javax.swing.BorderFactory.createEmptyBorder(5, 5, 5, 5));

        initButton.setFont(new java.awt.Font("Lucida Grande", 0, 18)); // NOI18N
        initButton.setText("Continua");
        initButton.setAlignmentX(0.5F);
        initButton.setMaximumSize(new java.awt.Dimension(122, 40));
        initButton.setMinimumSize(new java.awt.Dimension(122, 40));
        initButton.setPreferredSize(new java.awt.Dimension(122, 40));
        initButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                initButtonActionPerformed(evt);
            }
        });
        jPanel5.add(initButton);

        initPanel.add(jPanel5, java.awt.BorderLayout.SOUTH);

        getContentPane().add(initPanel, "init");

        matchPanel.setLayout(new java.awt.BorderLayout());

        createButton.setFont(new java.awt.Font("Lucida Grande", 0, 18)); // NOI18N
        createButton.setText("Crea Partita");
        createButton.setAlignmentX(0.5F);
        createButton.setMaximumSize(new java.awt.Dimension(172, 40));
        createButton.setMinimumSize(new java.awt.Dimension(122, 40));
        createButton.setPreferredSize(new java.awt.Dimension(172, 40));
        createButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                createButtonActionPerformed(evt);
            }
        });
        jPanel6.add(createButton);

        matchPanel.add(jPanel6, java.awt.BorderLayout.SOUTH);

        jPanel7.setBorder(javax.swing.BorderFactory.createEmptyBorder(20, 5, 5, 5));

        jPanel10.setLayout(new javax.swing.BoxLayout(jPanel10, javax.swing.BoxLayout.Y_AXIS));

        jPanel11.setBorder(javax.swing.BorderFactory.createEmptyBorder(5, 5, 5, 5));
        jPanel11.setAlignmentX(0.0F);
        jPanel11.setLayout(new java.awt.BorderLayout());

        jLabel3.setFont(new java.awt.Font("Lucida Grande", 0, 14)); // NOI18N
        jLabel3.setText("Robodromo:");
        jPanel11.add(jLabel3, java.awt.BorderLayout.WEST);

        robodromeCombo.setFont(new java.awt.Font("Lucida Grande", 0, 14)); // NOI18N
        robodromeCombo.setPreferredSize(new java.awt.Dimension(200, 33));
        jPanel11.add(robodromeCombo, java.awt.BorderLayout.CENTER);

        jPanel10.add(jPanel11);

        jPanel12.setBorder(javax.swing.BorderFactory.createEmptyBorder(5, 5, 10, 5));
        jPanel12.setAlignmentX(0.0F);
        jPanel12.setLayout(new java.awt.BorderLayout());

        jLabel4.setFont(new java.awt.Font("Lucida Grande", 0, 14)); // NOI18N
        jLabel4.setText("Fine partita:");
        jPanel12.add(jLabel4, java.awt.BorderLayout.WEST);

        endGameCombo.setFont(new java.awt.Font("Lucida Grande", 0, 14)); // NOI18N
        endGameCombo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "primo arrivato", "primi 3 arrivati", "tutti tranne l'ultimo" }));
        endGameCombo.setMinimumSize(new java.awt.Dimension(152, 27));
        endGameCombo.setPreferredSize(new java.awt.Dimension(152, 33));
        jPanel12.add(endGameCombo, java.awt.BorderLayout.CENTER);

        jPanel10.add(jPanel12);

        jPanel13.setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 5, 5, 5));
        jPanel13.setAlignmentX(0.0F);
        jPanel13.setLayout(new java.awt.BorderLayout());

        jLabel5.setFont(new java.awt.Font("Lucida Grande", 0, 14)); // NOI18N
        jLabel5.setText("Numero massimo giocatori:");
        jPanel13.add(jLabel5, java.awt.BorderLayout.WEST);

        maxPlayersCombo.setFont(new java.awt.Font("Lucida Grande", 0, 14)); // NOI18N
        maxPlayersCombo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "2", "3", "4", "5", "6", "7", "8" }));
        maxPlayersCombo.setPreferredSize(new java.awt.Dimension(100, 33));
        jPanel13.add(maxPlayersCombo, java.awt.BorderLayout.CENTER);

        jPanel10.add(jPanel13);

        jPanel14.setBorder(javax.swing.BorderFactory.createEmptyBorder(5, 5, 20, 5));
        jPanel14.setAlignmentX(0.0F);
        jPanel14.setLayout(new java.awt.BorderLayout());

        jLabel6.setFont(new java.awt.Font("Lucida Grande", 0, 14)); // NOI18N
        jLabel6.setText("Numero robot per giocatore:");
        jPanel14.add(jLabel6, java.awt.BorderLayout.WEST);

        nRobotsCombo.setFont(new java.awt.Font("Lucida Grande", 0, 14)); // NOI18N
        nRobotsCombo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "1", "2", "3", "4" }));
        nRobotsCombo.setPreferredSize(new java.awt.Dimension(100, 33));
        jPanel14.add(nRobotsCombo, java.awt.BorderLayout.CENTER);

        jPanel10.add(jPanel14);

        upgradeCheck.setFont(new java.awt.Font("Lucida Grande", 0, 14)); // NOI18N
        upgradeCheck.setText("Dotazione iniziale upgrade");
        jPanel10.add(upgradeCheck);

        jPanel7.add(jPanel10);

        matchPanel.add(jPanel7, java.awt.BorderLayout.CENTER);

        getContentPane().add(matchPanel, "match");

        playersPanel.setLayout(new java.awt.BorderLayout());

        jPanel8.setBorder(javax.swing.BorderFactory.createCompoundBorder(javax.swing.BorderFactory.createEmptyBorder(2, 2, 2, 2), javax.swing.BorderFactory.createCompoundBorder(javax.swing.BorderFactory.createEtchedBorder(), javax.swing.BorderFactory.createEmptyBorder(5, 5, 5, 5))));
        jPanel8.setLayout(new java.awt.BorderLayout());

        requestList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        requestList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                requestListValueChanged(evt);
            }
        });
        jScrollPane1.setViewportView(requestList);

        jPanel8.add(jScrollPane1, java.awt.BorderLayout.CENTER);

        acceptRequestButton.setText("Accetta...");
        acceptRequestButton.setEnabled(false);
        acceptRequestButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                acceptRequestButtonActionPerformed(evt);
            }
        });
        jPanel15.add(acceptRequestButton);

        rejectRequestButton.setText("Rifiuta");
        rejectRequestButton.setEnabled(false);
        rejectRequestButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rejectRequestButtonActionPerformed(evt);
            }
        });
        jPanel15.add(rejectRequestButton);

        jPanel8.add(jPanel15, java.awt.BorderLayout.SOUTH);

        playersPanel.add(jPanel8, java.awt.BorderLayout.WEST);

        robotRecapPanel.setLayout(new java.awt.GridLayout(2, 4));
        playersPanel.add(robotRecapPanel, java.awt.BorderLayout.CENTER);

        startMatchButton.setFont(new java.awt.Font("Lucida Grande", 0, 18)); // NOI18N
        startMatchButton.setText("Avvia");
        startMatchButton.setAlignmentX(0.5F);
        startMatchButton.setEnabled(false);
        startMatchButton.setMaximumSize(new java.awt.Dimension(122, 40));
        startMatchButton.setMinimumSize(new java.awt.Dimension(122, 40));
        startMatchButton.setPreferredSize(new java.awt.Dimension(122, 40));
        startMatchButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startMatchButtonActionPerformed(evt);
            }
        });
        jPanel16.add(startMatchButton);

        cancelMatchButton.setFont(new java.awt.Font("Lucida Grande", 0, 18)); // NOI18N
        cancelMatchButton.setText("Annulla");
        cancelMatchButton.setAlignmentX(0.5F);
        cancelMatchButton.setMaximumSize(new java.awt.Dimension(122, 40));
        cancelMatchButton.setMinimumSize(new java.awt.Dimension(122, 40));
        cancelMatchButton.setPreferredSize(new java.awt.Dimension(122, 40));
        cancelMatchButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cancelMatchButtonActionPerformed(evt);
            }
        });
        jPanel16.add(cancelMatchButton);

        playersPanel.add(jPanel16, java.awt.BorderLayout.SOUTH);

        getContentPane().add(playersPanel, "players");

        ongoingMatchPanel.setMaximumSize(null);
        ongoingMatchPanel.setMinimumSize(new java.awt.Dimension(852, 728));

        titolo.setFont(new java.awt.Font("Tempus Sans ITC", 3, 48)); // NOI18N
        titolo.setForeground(new java.awt.Color(0, 153, 51));
        titolo.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        titolo.setText("Server RoboGP");

        javax.swing.GroupLayout controlActionPanelLayout = new javax.swing.GroupLayout(controlActionPanel);
        controlActionPanel.setLayout(controlActionPanelLayout);
        controlActionPanelLayout.setHorizontalGroup(
            controlActionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 183, Short.MAX_VALUE)
        );
        controlActionPanelLayout.setVerticalGroup(
            controlActionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 594, Short.MAX_VALUE)
        );

        tabellone.setLeftComponent(controlActionPanel);
        tabellone.setRightComponent(jSplitPane1);

        javax.swing.GroupLayout ongoingMatchPanelLayout = new javax.swing.GroupLayout(ongoingMatchPanel);
        ongoingMatchPanel.setLayout(ongoingMatchPanelLayout);
        ongoingMatchPanelLayout.setHorizontalGroup(
            ongoingMatchPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ongoingMatchPanelLayout.createSequentialGroup()
                .addGroup(ongoingMatchPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(ongoingMatchPanelLayout.createSequentialGroup()
                        .addGap(96, 96, 96)
                        .addComponent(titolo, javax.swing.GroupLayout.PREFERRED_SIZE, 697, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(ongoingMatchPanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(tabellone, javax.swing.GroupLayout.PREFERRED_SIZE, 812, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(0, 30, Short.MAX_VALUE))
        );
        ongoingMatchPanelLayout.setVerticalGroup(
            ongoingMatchPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, ongoingMatchPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(titolo)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(tabellone, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(22, 22, 22))
        );

        getContentPane().add(ongoingMatchPanel, "ongoing");

        setBounds(0, 0, 788, 455);
    }// </editor-fold>//GEN-END:initComponents

    private void initButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_initButtonActionPerformed
        int num = 0;
        boolean ok = true;
        try {
            num = Integer.parseInt(this.portField.getText().trim());
        } catch (NumberFormatException ex) {
            ok = false;
            JOptionPane.showMessageDialog(this, "La porta deve essere un numero\ncompreso fra 1024 e 65535");
        }
        if (ok && (num < 1024 || num > 65535)) {
            ok = false;
            JOptionPane.showMessageDialog(this, "La porta deve essere un numero\ncompreso fra 1024 e 65535");
        }
        if (ok) {
            this.inizPartCtrl.iniziaCreazionePartita(num, this.keyField.getText().trim());
            this.setupMatchPanel();
            ((CardLayout) this.getContentPane().getLayout()).show(this.getContentPane(), "match");
        }
    }//GEN-LAST:event_initButtonActionPerformed

    private void createButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_createButtonActionPerformed
        String rbdName = this.robodromeCombo.getSelectedItem().toString();
        int endGameOpt = this.endGameCombo.getSelectedIndex();
        boolean upgradeOpt = this.upgradeCheck.isSelected();
        int nPl = this.maxPlayersCombo.getSelectedIndex() + 2;
        int nRob = this.nRobotsCombo.getSelectedIndex() + 1;
        boolean ok = true;
        if (nPl * nRob > Match.ROBOTSINGAME) {
            ok = false;
            JOptionPane.showMessageDialog(this, "Con " + nRob + " per giocatore, non si possono avere " + nPl + " giocatori.\n"
                    + "Il massimo numero di robot nel gioco è " + Match.ROBOTSINGAME);
        }
        if (ok) {
            MatchManagerApp.rdView = new RobodromeView(new Robodrome("robodromes\\" + rbdName + ".txt"), 45);
            this.inizPartCtrl.creaPartita(rbdName, nPl, nRob, Match.EndGame.values()[endGameOpt], upgradeOpt);
            this.requestList.setModel(this.inizPartCtrl.getRequestList());
            ArrayList<RobotMarker> allRobots = Match.getInstance().getAllRobots();
            this.robotPanel = new RobotStatePanel[allRobots.size()];
            this.robotRecapPanel.removeAll();
            for (int i = 0; i < robotPanel.length; i++) {
                this.robotPanel[i] = new RobotStatePanel(allRobots.get(i));
                this.robotRecapPanel.add(this.robotPanel[i]);
            }
            ((CardLayout) this.getContentPane().getLayout()).show(this.getContentPane(), "players");
        }
    }//GEN-LAST:event_createButtonActionPerformed

    private void requestListValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_requestListValueChanged
        boolean enabled = (this.requestList.getSelectedIndex() >= 0);
        this.acceptRequestButton.setEnabled(enabled && this.inizPartCtrl.canAcceptMoreRequests());
        this.rejectRequestButton.setEnabled(enabled);
    }//GEN-LAST:event_requestListValueChanged

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        this.inizPartCtrl.chiudi();
    }//GEN-LAST:event_formWindowClosing

    private void acceptRequestButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_acceptRequestButtonActionPerformed
        int pos = this.requestList.getSelectedIndex();
        String nickname = this.requestList.getSelectedValue();
        ArrayList<RobotMarker> robots = Match.getInstance().getAvailableRobots();
        this.robotChooser.setup(robots, Match.getInstance().getRobotsPerPlayer());
        this.robotChooser.setVisible(true);
        if (this.robotChooser.getCloseStatus() == JOptionPane.OK_OPTION) {
            ((DefaultListModel<String>) this.requestList.getModel()).remove(pos);
            this.inizPartCtrl.accettaRichiesta(nickname, this.robotChooser.getSelection());
            this.acceptRequestButton.setEnabled(this.requestList.getSelectedIndex() >= 0 && this.inizPartCtrl.canAcceptMoreRequests());
            this.startMatchButton.setEnabled(this.inizPartCtrl.canStartMatch());
            for (RobotStatePanel rsp : robotPanel) {
                rsp.update();
            }
            this.robotRecapPanel.updateUI();
        }
    }//GEN-LAST:event_acceptRequestButtonActionPerformed

    private void rejectRequestButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rejectRequestButtonActionPerformed
        int pos = this.requestList.getSelectedIndex();
        String nickname = this.requestList.getSelectedValue();
        this.inizPartCtrl.rifiutaRichiesta(nickname);
        ((DefaultListModel<String>) this.requestList.getModel()).remove(pos);
    }//GEN-LAST:event_rejectRequestButtonActionPerformed

    private void cancelMatchButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cancelMatchButtonActionPerformed
        this.inizPartCtrl.annullaPartita();
        ((CardLayout) this.getContentPane().getLayout()).show(this.getContentPane(), "match");
    }//GEN-LAST:event_cancelMatchButtonActionPerformed

    private void startMatchButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startMatchButtonActionPerformed
        this.inizPartCtrl.avviaPartita();
        ((CardLayout) this.getContentPane().getLayout()).show(this.getContentPane(), "ongoing");
        //ongoingMatchPanel.add(this.rdView);
        jSplitPane1.setRightComponent(rdView);
        TOTALROBOTS = Match.getInstance().getRobotsPerPlayer() * Match.getInstance().getPlayerCount();
        for (int i = 0; i < TOTALROBOTS; i++) {
            RobotMarker rm = Match.getInstance().getAllRobots().get(i);
            int[] coord = getFreeDock(i + 1);
            rdView.placeRobot(rm, Direction.E, coord[0], coord[1], true);
            rm.setX(coord[1]);
            rm.setY(coord[0]);
        }
    }//GEN-LAST:event_startMatchButtonActionPerformed
    
    public void executeCommands(Card[][] cards, int index) throws InterruptedException {
        ArrayList<Card> comm = new ArrayList();
        for (Card[] card : cards) {
            if (card[index] != null) {
                comm.add(card[index]);
            }
        }
        comm = Card.getSortedList(comm);
        for (int i = 0; i < comm.size(); i++) {
            int ind = comm.get(i).getIdOwner();
            switch (comm.get(i).getCommand()) {
                case "turnL":
                    turnL(Match.getInstance().getAllRobots().get(ind));
                    break;
                case "turnR":
                    turnR(Match.getInstance().getAllRobots().get(ind));
                    break;
                case "Uturn":
                    Uturn(Match.getInstance().getAllRobots().get(ind));
                    break;
                case "move1":
                    move1(Match.getInstance().getAllRobots().get(ind));
                    break;
                case "move2":
                    move2(Match.getInstance().getAllRobots().get(ind));
                    break;
                case "move3":
                    move3(Match.getInstance().getAllRobots().get(ind));
                    break;
                case "backup":
                    Uturn(Match.getInstance().getAllRobots().get(ind));
                    break;
            }
            updateCheckPoint(Match.getInstance().getAllRobots().get(ind));
        }
        MatchManagerApp.rdView.play();
        Thread.sleep(6000);
    }
    
    public void move3(RobotMarker robmar) {
        int movement = checkMoreWalls(robmar.getX(), robmar.getY(), robmar.getDir(), true, robmar);
        moveAndSetPosition(movement, robmar);
        checkCell(robmar.getX(), robmar.getY(), robmar);
        rdView.addPause(500);
    }
    
    public void move2(RobotMarker robmar) {
        int movement = checkMoreWalls(robmar.getX(), robmar.getY(), robmar.getDir(), false, robmar);
        moveAndSetPosition(movement, robmar);
        checkCell(robmar.getX(), robmar.getY(), robmar);
        rdView.addPause(500);
    }
    
    public void move1(RobotMarker robmar) {
        if (checkWalls(robmar.getX(), robmar.getY(), robmar.getDir())) {    //se la strada è libera
            moveAndSetPosition(1, robmar);
            checkCell(robmar.getX(), robmar.getY(), robmar);
        }
        rdView.addPause(500);
    }
    
    public void Uturn(RobotMarker robmar) {
        rdView.addRobotMove(robmar, 0, robmar.getDir(), Rotation.CCW180);
        switch (robmar.getDir()) {
            case N:
                robmar.setDir(Direction.S);
                break;
            case S:
                robmar.setDir(Direction.N);
                break;
            case E:
                robmar.setDir(Direction.W);
                break;
            case W:
                robmar.setDir(Direction.E);
                break;
        }
        rdView.addPause(500);
    }
    
    public void turnL(RobotMarker robmar) {
        rdView.addRobotMove(robmar, 0, robmar.getDir(), Rotation.CCW90);
        switch (robmar.getDir()) {
            case N:
                robmar.setDir(Direction.W);
                break;
            case S:
                robmar.setDir(Direction.E);
                break;
            case E:
                robmar.setDir(Direction.N);
                break;
            case W:
                robmar.setDir(Direction.S);
                break;
        }
        rdView.addPause(500);
    }
    
    public void turnR(RobotMarker robmar) {
        rdView.addRobotMove(robmar, 0, robmar.getDir(), Rotation.CW90);
        switch (robmar.getDir()) {
            case N:
                robmar.setDir(Direction.E);
                break;
            case S:
                robmar.setDir(Direction.W);
                break;
            case E:
                robmar.setDir(Direction.S);
                break;
            case W:
                robmar.setDir(Direction.N);
                break;
        }
        rdView.addPause(500);
    }
    
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MatchManagerApp.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            MatchManagerApp.singleInstance = new MatchManagerApp();
            MatchManagerApp.singleInstance.setVisible(true);
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton acceptRequestButton;
    private javax.swing.JButton cancelMatchButton;
    private javax.swing.JPanel controlActionPanel;
    private javax.swing.JButton createButton;
    private javax.swing.JComboBox<String> endGameCombo;
    private javax.swing.JButton initButton;
    private javax.swing.JPanel initPanel;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JTextField keyField;
    private javax.swing.JPanel matchPanel;
    private javax.swing.JComboBox<String> maxPlayersCombo;
    private javax.swing.JComboBox<String> nRobotsCombo;
    private javax.swing.JPanel ongoingMatchPanel;
    private javax.swing.JPanel playersPanel;
    private javax.swing.JTextField portField;
    private javax.swing.JButton rejectRequestButton;
    private javax.swing.JList<String> requestList;
    private javax.swing.JComboBox<String> robodromeCombo;
    private javax.swing.JPanel robotRecapPanel;
    private javax.swing.JButton startMatchButton;
    private javax.swing.JSplitPane tabellone;
    private javax.swing.JLabel titolo;
    private javax.swing.JCheckBox upgradeCheck;
    // End of variables declaration//GEN-END:variables

    private void setupMatchPanel() {
        File robodromeDir = new File("robodromes");
        File[] robodromeFiles = robodromeDir.listFiles();
        String[] opts = new String[robodromeFiles.length];
        for (int i = 0; i < opts.length; i++) {
            opts[i] = robodromeFiles[i].getName().split("\\.")[0];
        }
        this.robodromeCombo.setModel(new DefaultComboBoxModel<>(opts));
    }
    
    public void checkCell(int x, int y, RobotMarker robmar) {
        System.out.println("x: " + x + "   y: " + y + "  direzione " + robmar.getDir());
        BoardCell cell = Match.getInstance().getTheRobodrome().getCell(y, x);
        if (cell instanceof BeltCell) {
            BeltCell belt = (BeltCell) cell;
            rdView.addRobotMove(robmar, 1, belt.getOutputDirection(), Rotation.NO);
            if (belt.getOutputDirection() != null) {
                switch (belt.getOutputDirection()) {
                    case S:
                        robmar.setY(robmar.getY() + 1);
                        checkCell(x, y + 1, robmar);
                        break;
                    case N:
                        robmar.setY(robmar.getY() - 1);
                        checkCell(x, y - 1, robmar);
                        break;
                    case E:
                        robmar.setX(robmar.getX() + 1);
                        checkCell(x + 1, y, robmar);
                        break;
                    case W:
                        robmar.setX(robmar.getX() - 1);
                        checkCell(x - 1, y, robmar);
                        break;
                }
            }
        } else if (cell instanceof PitCell) {
            rdView.addRobotFall(robmar);
            robmar.setX(0);
            robmar.setY(5);
        }
    }
    
    public void moveAndSetPosition(int movement, RobotMarker robmar) {
        int x, y;
        if (null != robmar.getDir()) {
            switch (robmar.getDir()) {
                case S:
                    y = getRightY(robmar.getY(), false, movement);
                    //  change = (robmar.getY() + movement) >= robodrome.getRowCount();
                    robmar.setY(y);
                    rdView.addRobotMove(robmar, movement, robmar.getDir(), Rotation.NO);
                    break;
                
                case N:
                    y = getRightY(robmar.getY(), true, movement);
                    robmar.setY(y);
                    rdView.addRobotMove(robmar, movement, robmar.getDir(), Rotation.NO);
                    break;
                
                case E:
                    x = getRightX(robmar.getX(), false, movement);
                    robmar.setX(x);
                    rdView.addRobotMove(robmar, movement, robmar.getDir(), Rotation.NO);
                    break;
                
                case W:
                    x = getRightX(robmar.getX(), true, movement);
                    robmar.setX(x);
                    rdView.addRobotMove(robmar, movement, robmar.getDir(), Rotation.NO);
                    break;
            }
        }
    }

    /*restituisce il numero di celle che il robot può percorrere
    se moveThree è false portanno esserci solo 2 celle al massimo*/
    public int checkMoreWalls(int x, int y, Direction dir, boolean moveThree, RobotMarker robmar) {
        int realX, realY;
        if (!checkWalls(x, y, dir)) {
            return 0;
        } else if (dir != null) {
            switch (dir) {
                case S:
                    realY = getRightY(robmar.getY(), false, 1);
                    if (!checkWalls(robmar.getX(), realY, Direction.S)) {
                        return 1;
                    }
                    break;
                case N:
                    realY = getRightY(robmar.getY(), true, 1);
                    if (!checkWalls(robmar.getX(), realY, Direction.N)) {
                        return 1;
                    }
                    break;
                case E:
                    realX = getRightX(robmar.getX(), false, 1);
                    if (!checkWalls(realX, robmar.getY(), Direction.E)) {
                        return 1;
                    }
                    break;
                case W:
                    realX = getRightX(robmar.getX(), true, 1);
                    if (!checkWalls(realX, robmar.getY(), Direction.W)) {
                        return 1;
                    }
                    break;
            }
        }
        if (moveThree) {
            switch (robmar.getDir()) {
                case S:
                    realY = getRightY(robmar.getY(), false, 2);
                    if (!checkWalls(robmar.getX(), realY, Direction.S)) {
                        return 2;
                    }
                    break;
                case N:
                    realY = getRightY(robmar.getY(), true, 2);
                    if (!checkWalls(robmar.getX(), realY, Direction.N)) {
                        return 2;
                    }
                    break;
                case E:
                    realX = getRightX(robmar.getX(), false, 2);
                    if (!checkWalls(realX, robmar.getY(), Direction.E)) {
                        return 2;
                    }
                    break;
                case W:
                    realX = getRightX(robmar.getX(), true, 2);
                    if (!checkWalls(realX, robmar.getY(), Direction.W)) {
                        return 2;
                    }
            }
            return 3;
        } else {
            return 2;
        }
        
    }

    /*ritorna false se la cella ha un muro nella posixione indicata,
    true se non ci sono ostacoli               */
    private boolean checkWalls(int x, int y, Direction dir) {
        if (Match.getInstance().getTheRobodrome().getCell(y, x) instanceof FloorCell) {
            FloorCell floor = (FloorCell) Match.getInstance().getTheRobodrome().getCell(y, x);
            FloorCell nextFloor;
            int rightX, rightY;
            switch (dir) {
                case N:
                    rightY = getRightY(y, true, 1);
                    if (Match.getInstance().getTheRobodrome().getCell(rightY, x) instanceof FloorCell) {
                        nextFloor = (FloorCell) Match.getInstance().getTheRobodrome().getCell(rightY, x);
                        return !floor.hasWall(dir) && !nextFloor.hasWall(Direction.S);
                    }
                    break;
                case S:
                    rightY = getRightY(y, false, 1);
                    if (Match.getInstance().getTheRobodrome().getCell(rightY, x) instanceof FloorCell) {
                        nextFloor = (FloorCell) Match.getInstance().getTheRobodrome().getCell(rightY, x);
                        return !floor.hasWall(dir) && !nextFloor.hasWall(Direction.N);
                    }
                    break;
                case E:
                    rightX = getRightX(x, false, 1);
                    if (Match.getInstance().getTheRobodrome().getCell(y, rightX) instanceof FloorCell) {
                        nextFloor = (FloorCell) Match.getInstance().getTheRobodrome().getCell(y, rightX);
                        return !floor.hasWall(dir) && !nextFloor.hasWall(Direction.W);
                    }
                    break;
                case W:
                    rightX = getRightX(x, true, 1);
                    if (Match.getInstance().getTheRobodrome().getCell(y, rightX) instanceof FloorCell) {
                        nextFloor = (FloorCell) Match.getInstance().getTheRobodrome().getCell(y, rightX);
                        return !floor.hasWall(dir) && !nextFloor.hasWall(Direction.E);
                    }
                    break;
            }
            return !floor.hasWall(dir);
        } else {
            return true;
        }
    }

    /* restituisce il giusto posizionamento sull'asse X. Da usare per controllare 
        che il robot si muova all'interno dei limiti del robodrommo */
    private int getRightX(int x, boolean westDir, int movement) {
        if (westDir) {
            if (x - movement < 0) {
                return x - movement + Match.getInstance().getTheRobodrome().getColumnCount();
            } else {
                return x - movement;
            }
        } else {
            if (x >= Match.getInstance().getTheRobodrome().getColumnCount()) {
                return (x + movement) % Match.getInstance().getTheRobodrome().getColumnCount();
            } else {
                return x + movement;
            }
        }
    }
    
    private int getRightY(int y, boolean northDir, int movement) {
        if (northDir) {
            if (y - movement < 0) {
                return y - movement + Match.getInstance().getTheRobodrome().getRowCount();
            } else {
                return y - movement;
            }
        } else {
            if (y + movement >= Match.getInstance().getTheRobodrome().getRowCount()) {
                return (y + movement) % Match.getInstance().getTheRobodrome().getRowCount();
            } else {
                return y + movement;
            }
        }
    }
    
    private RobotMarker robotInPath(RobotMarker moved, int x, int y) {
        for (RobotMarker rm : Match.getInstance().getAllRobots()) {
            if (rm != null && !rm.equals(moved)) {
                if (rm.getX() == x && rm.getY() == y) {
                    move1(rm);
                    return rm;
                }
            }
        }
        return null;
    }
    
    private int[] getFreeDock(int dock) {
        int[] res = new int[2];
        for (int row = 0; row < Match.getInstance().getTheRobodrome().getRowCount(); row++) {
            for (int col = 0; col < Match.getInstance().getTheRobodrome().getColumnCount(); col++) {
                BoardCell bc = Match.getInstance().getTheRobodrome().getCell(row, col);
                if (bc instanceof FloorCell) {
                    FloorCell fc = (FloorCell) bc;
                    if (fc.getDock() == dock) {
                        res[0] = row;
                        res[1] = col;
                        System.out.println("y :" + row + "  x :" + col);
                        return res;
                    }
                }
            }
        }
        return null;
    }
    
    private void updateCheckPoint(RobotMarker rm) {
        BoardCell cell = Match.getInstance().getTheRobodrome().getCell(rm.getY(), rm.getX());
        if (cell instanceof FloorCell) {
            FloorCell fCell = (FloorCell) cell;
            if (fCell.getCheckpoint() == rm.getnCheckPoint() + 1) {
                rm.setnCheckPoint(fCell.getCheckpoint());
            }
        }
    }
}
